void* Context::GetAlignedPointerFromEmbedderData(int index);
Local<Value> Context::GetEmbedderData(int index);
Local<Value> Object::GetInternalField(int index);

/** Get a template included in the snapshot by index. */
static MaybeLocal<FunctionTemplate> FunctionTemplate::FromSnapshot(Isolate* isolate,
																								 size_t index);
/** Get a template included in the snapshot by index. */
static MaybeLocal<ObjectTemplate> ObjectTemplate::FromSnapshot(Isolate* isolate,
																							 size_t index);

/**
 * Set the default context to be included in the snapshot blob.
 * The snapshot will not contain the global proxy, and we expect one or a
 * global object template to create one, to be provided upon deserialization.
 *
 * \param callback optional callback to serialize internal fields.
 */
void Isolate::SetDefaultContext(Local<Context> context,
											 SerializeInternalFieldsCallback callback =
													 SerializeInternalFieldsCallback());

/**
 * Creates a new context and returns a handle to the newly allocated
 * context.
 *
 * \param isolate The isolate in which to create the context.
 *
 * \param extensions An optional extension configuration containing
 * the extensions to be installed in the newly created context.
 *
 * \param global_template An optional object template from which the
 * global object for the newly created context will be created.
 *
 * \param global_object An optional global object to be reused for
 * the newly created context. This global object must have been
 * created by a previous call to Context::New with the same global
 * template. The state of the global object will be completely reset
 * and only object identify will remain.
 */
static Local<Context> Context::New(
		Isolate* isolate, ExtensionConfiguration* extensions = NULL,
		MaybeLocal<ObjectTemplate> global_template = MaybeLocal<ObjectTemplate>(),
		MaybeLocal<Value> global_object = MaybeLocal<Value>(),
		DeserializeInternalFieldsCallback internal_fields_deserializer =
				DeserializeInternalFieldsCallback());

/**
 * Create a new context from a (non-default) context snapshot. There
 * is no way to provide a global object template since we do not create
 * a new global object from template, but we can reuse a global object.
 *
 * \param isolate See v8::Context::New.
 *
 * \param context_snapshot_index The index of the context snapshot to
 * deserialize from. Use v8::Context::New for the default snapshot.
 *
 * \param embedder_fields_deserializer Optional callback to deserialize
 * internal fields. It should match the SerializeInternalFieldCallback used
 * to serialize.
 *
 * \param extensions See v8::Context::New.
 *
 * \param global_object See v8::Context::New.
 */

static MaybeLocal<Context> Context::FromSnapshot(
		Isolate* isolate, size_t context_snapshot_index,
		DeserializeInternalFieldsCallback embedder_fields_deserializer =
				DeserializeInternalFieldsCallback(),
		ExtensionConfiguration* extensions = nullptr,
		MaybeLocal<Value> global_object = MaybeLocal<Value>());

/**
 * A container for extension names.
 */
class V8_EXPORT ExtensionConfiguration {
 public:
  ExtensionConfiguration() : name_count_(0), names_(NULL) { }
  ExtensionConfiguration(int name_count, const char* names[])
      : name_count_(name_count), names_(names) { }

  const char** begin() const { return &names_[0]; }
  const char** end()  const { return &names_[name_count_]; }

 private:
  const int name_count_;
  const char** names_;
};



/**
 * Callback and supporting data used in SnapshotCreator to implement embedder
 * logic to serialize internal fields.
 */
struct SerializeInternalFieldsCallback {
  typedef StartupData (*CallbackFunction)(Local<Object> holder, int index,
                                          void* data);
  SerializeInternalFieldsCallback(CallbackFunction function = nullptr,
                                  void* data_arg = nullptr)
      : callback(function), data(data_arg) {}
  CallbackFunction callback;
  void* data;
};
// Note that these fields are called "internal fields" in the API and called
// "embedder fields" within V8.
typedef SerializeInternalFieldsCallback SerializeEmbedderFieldsCallback;

/**
 * Callback and supporting data used to implement embedder logic to deserialize
 * internal fields.
 */
struct DeserializeInternalFieldsCallback {
  typedef void (*CallbackFunction)(Local<Object> holder, int index,
                                   StartupData payload, void* data);
  DeserializeInternalFieldsCallback(CallbackFunction function = nullptr,
                                    void* data_arg = nullptr)
      : callback(function), data(data_arg) {}
  void (*callback)(Local<Object> holder, int index, StartupData payload,
                   void* data);
  void* data;
};
typedef DeserializeInternalFieldsCallback DeserializeEmbedderFieldsCallback;


2015 Custom startup snapshots
https://v8project.blogspot.com/2015/09/custom-startup-snapshots.html

2017 Energizing Atom with V8's custom start-up snapshot
https://v8project.blogspot.com/2017/05/energizing-atom-with-v8s-custom-start.html

2017 Native functions can be included in the snapshot with newer V8.
https://github.com/atom/electron-link/issues/1

2017 Design doc: embedder provided object templates in context snapshot
https://docs.google.com/document/d/1NBmPxgkKuipRZFAzq2IQTDM4qzouyIMh_DfqPaIw1hE/edit

2017 Serializing internal fields in V8
https://docs.google.com/document/d/1wIbujf-bgQUkrM0pMUCRn57oOw8ErFOMQG35sbZrWLU/edit



